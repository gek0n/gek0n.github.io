---
title: Отображение Unicode строк в C++
description: Статья описывает особенности обработки UTF-8 и UTF-16 строк на разных операционных системах с использованием разных компиляторов
keywords: unicode, utf8, utf16, c++, windows, linux, vs2019, visual_studio, mingw, clang
tags:
    - unicode
    - windows
    - linux
    - string
    - c++
date: 05.08.2020
---
Для корректного вывода символов Unicode в консоли, необходимо выполнить следующие требования:

1. **Консоль должна уметь отображать выбранную кодировку Unicode**  
Для этого шрифт консоли должен содержать начертания для всех символов Unicode (TrueType), кодировка, в которой символы выводятся на экран (кодовая страница в Windows), должна соответствовать соответствующей кодировке Unicode.
2. **Консольное приложение должно отправлять символы в консоль в выбранной кодировке Unicode**  
Стартующее приложение наследует настройки по умолчанию от консоли, поэтому в некоторых системах требуется явно выставить кодировку для stdout.
3. **Консольное приложение должно понимать выбранную кодировку Unicode, чтобы отправлять символы, состоящие из нескольких байт, как один символ в консоль**  
Библиотеки, которые реализуют коммуникацию с stdout хендлом, должны правильно понимать соответствующую кодировку Unicode, чтобы обрабатывать многобайтовые символы за один раз. Для этого в некоторых случаях достаточно явного указания локали для библиотеки, а иногда требуется также установить буфер, который позволит отправлять текст из многобайтовых символов одной операцией, однако такие буферы не гарантируют что символы не отправятся частично.
4. **Компилятор должен поддерживать работу с символами в выбранной кодировке Unicode**  
Компилятор должен правильно интерпретировать строковые литералы, согласно документации, а также уметь принимать на вход файлы исходного кода в разных кодировках.  
5. **Файлы исходного кода (либо файлы ресурсов) должны быть сохранены в выбранной кодировке Unicode**  
Это необходимо сделать, чтобы не увеличивать количество настроек компилятора.

### Подробное описание

#### Кодировка Unicode

Стандарт, [предложенный в 1991 году][0] для кодирования всех символов, не требующий переключения кодовых страниц. Состоит из двух основных частей: универсального набора символов (UCS) и семейства кодировок (UTF). UCS определяет каждому символу уникальный код, в то время как UTF определяет способы преобразования кодов этих символов для передачи в потоке или файле.

Кодировка [UTF-8][0] позволяет записывать символы таким образом, что ASCII символы могут быть обработаны любой программой, работающей с ASCII, и наоборот. Остальные символы Unicode отображаются при помощи последовательности от 2 до 4 байт, где первый байт всегда имеет маску `11xxxxxx`, а остальные `10xxxxxx`.

Кодировка [UTF-16][0] позволяет записать каждый символ 1 или 2 словами (1 слово = 2 байта).

Кодировка [UTF-32][0] позволяет записать каждый символ при помощи ровно 4 байт, а также непосредственное индексирование в строках, простые операции замены и вставки.

Для UTF-16 и UTF-32 существует возможность записи байт: младший перед старшим (little endian, LE) или старший перед младшим (big endian, BE).

Для указания порядка записи байт, в файле иногда применяется [маркер последовательности байт][0] (byte order mark, BOM) - символ неразрывного пробела нулевой ширины U+FEFF. По его записи легко различить кодировку.

#### Поддержка Unicode в ОС

Все современные ОС поддерживают Unicode, но для совместимости с различными старыми системами, подсистемами и стандартами остались и старые способы адресации символов.

##### Windows

[Первые версии Windows][3] и других ОС практически не разделяли на разные понятия байты и символы, поэтому 1 байт мог кодировать 255 символов. Чтобы иметь возможность выводить на экран символы, относящиеся к национальным алфавитам, а также выводить другие специальные символы, в Windows была взята идея кодовых страниц ([Code pages][4]).

Кодовые страницы это кодировки, которые состоят из первых 128 значений ASCII символов, и ещё 127 символов меняются от страницы к странице и представляют национальные (ANSI) или иные символы (OEM). Символы кодовых страниц с номерами от `0x00` до `0x1F` и `0x7F` обычно представляют универсальные управляющие символы, символы с кодами от `0x20` до `0x7E` - печатные символы, символы с кодами от `0x80` до `0xFF` различаются у каждой кодовой страницы.

По внутреннему устройству кодовые страницы могут быть [однобайтовые (SBCS) и двухбайтовые (DBCS)][4]. Первые представляют прямую кодировку одного символа одним байтом, итого 256 символов, вторые обычно используют последовательность из _двух_ байт для представления одного символа. Также существуют [многобайтовые (MBCS)][4] кодировки, которые используют более длинные последовательности байт для представления одного символа. Однако стоит отметить, что ни одна из этих кодировок не умеет полностью отображать все символы Unicode.

Начиная с линейки **Windows NT** [система Windows поддерживает кодировку Unicode UTF-16][5], которая использует 2 байта для каждого символа. Все внутренние представления строковых данных в Windows [по умолчанию хранятся и обрабатываются в UTF-16][6]. Такие строки, согласно внутренней терминологии, называются `WideChar`, в то время как все кодовые страницы называются `MultiByte`. Рекомендуется во всех приложениях для Windows использовать для внутреннего представления кодировку UTF-16.

Для поддержки старого 8-ми и 7-ми битного окружения в Windows добавлена [поддержка UTF-7 и UTF-8][6] в виде многобайтовых кодовых страниц. 

Часто требуется работа с окружением, поддерживающим только MBCS кодировки, тогда [следует использовать функции][6] для преобразования `MultiByteToWideChar` и `WideCharToMultiByte`.

Командной строке Windows при создании назначается кодовая страница по умолчанию, номер которой [берётся из реестра][7]. Поменять кодовую страницу можно либо при помощи утилиты `chcp` или [использовав функцию `SetConsoleOutputCP`][8] в приложении. По умолчанию терминал Windows умеет выводить MultiByte символы и WideChar символы, главное чтобы шрифт, используемый терминалом поддерживал Unicode символы ([TrueType][9]).

В Windows по умолчанию используется [файловая система NTFS][10], которая поддерживает имена файлов в формате UTF-16, содержимое файла может быть в любой кодировке.

##### Linux

В Linux нет понятия кодовых страниц, вместо этого используется понятие локали (locale) с [Unicode UTF-8 в качестве основной кодировки][11]. В этой операционной системе различные приложения могут иметь [разную локаль][12], а некоторые процессы могут иметь разные локали для разных [категорий][13]. Программы на `C` и `C++` стартуют [по умолчанию с локалью **C**][14].

Командная строка Linux при создании [автоматически получает системную локаль][15], которая почти всегда основана на UTF-8. По умолчанию шрифты терминала в Linux обычно поддерживают символы Unicode.

Linux может иметь различные файловые системы, большинство из них воспринимают имена файлов как [обычную последовательность байт][16], а не символов, поэтому могут приниматься различные кодировки. Предпочтительной является UTF-8 как для имени файла, так и для его содержимого.

#### Понятие локали

Понятие [системной локали в Windows][1] содержит в себе название шрифта, и кодовой страницы, которые используются для ANSI программ. Программы использующие Unicode не зависят от этой настройки.

Понятие [системной локали в Linux][2] содержит в себе большой список раличных категорий, к которым могут быть применены набор национальных правил, определяющих не только язык и кодировку, но и правила написания дат, времени, адресов и т.д.

#### Язык С++ и Unicode

В терминологии языка C++ сипользуется три основных понятия:
- [однобайтовые строки (Null-terminated byte strings, NTBS)][17];
- [многобайтовые строки (Null-terminated multibyte strings, NTMBS)][18];
- [широкие строки (Null-terminated wide strings, NTWS)][19].

Основываются эти понятия на основе шаблонных классов [`std::basic_string<T>` и `std::basic_string_view<T>`][20], из которых получаются классы `std::string`, `std::wstring`, `std::string_view` и `std::wstring_view`. Эти классы используют в виде параметра шаблона базовые типы [`char` и `wchar_t`][21]. Размеры данных типов зависят от ОС и платформы, но чаще всего тип `char` имеет размер равный 8 бит, а тип `wchar_t` [на большинстве систем имеет размер 32 бита, а на системе Windows имеет размер 16 бит][21].

##### std::string и std::wstring

Для работы с NTBS используется `std::string`. При этом все методы этого класса могут напрямую корректно работать, поскольку в строках этого типа каждый символ кодируется ровно одним байтом.

Для работы с NTMBS также используется `std::string`, однако методы не могут корректно адресовать символы по индексу, не могут посчитать правильную длину строки, потому что один символ может быть представлен более чем одним байтом.

Для работы с NTWS используется `std::wstring`. Все методы этого класса напрямую корректно работают, потому что каждый символ имеет фиксированный размер.

Стоит обратить внимание, что строки `std::string` спроектированы таким образом, что хранят строку как массив байт, без какой-либо информации о кодировке, поэтому корректно работают в одной, заранее установленной локали.

Конвертация между этими двумя типами напрямую через конструктор `std::wstring(string.begin(), string.end())` не имеет смысла, поскольку строки значительно не совпадают по байтовому представлению в памяти.

Естественно, для строк NTMBS функции типа `std::isspace()` или `std::isalpha()` будут работать не корректно.

##### Строковые литералы

Для задания [строковых литералов][22] NTBS и NTMBS используется нотация `"literal"`. Для задания строковых литералов NTWS используется нотация `L"literal"`. Стоит обратить внимание, что отличить однобайтовую от многобайтовой строки проще всего по наличию non-ASCII символов. Литералы первого вида автоматически определяются как тип `const char[N]`, а литералы второго вида определяются как тип `const wchar_t[N]`.

##### Вывод на экран

Стандартно для вывода на экран используется C-style способ `printf`, `wprintf` и C++-style способ `std::printf`, `std::wprintf` и операторы потокового вывода `std::cout` и `std::wcout`. Для вывода строк функциями типа `printf` используется форматная строка, где для подстановки аргумента могут быть использованы спецификаторы `%s` или `%ls`. Существует также спецификатор `%S`, но он не является стандартизированным и реализован преимущественно в компиляторах MSVS.

#### Компиляторы и Unicode

Большинство современных компиляторов понимают Unicode строки и в качестве исходников, и в строковых литералах. У многих компиляторов есть соответствующие флаги, которые могут настраивать такое поведение.

_Следующие утверждения получены экспериментальным путём._

Для корректного вывода UTF-8 в консоль Windows необходимо установить кодовую страницу в значение `65001`.

##### Windows MinGW и MinGW64

```
MinGW-make version is GNU Make 3.82.90
MinGW64-make version is GNU Make 4.2.1
```

- Позволяет отобразить UTF-8 строку, хранящуюся в типе `std::string` при помощи `printf` или `std::printf`, используя спецификатор `%s`.
- Позволяет отобразить UTF-16 строку, хранящуюся в типе `std::wstring` при помощи `wprintf` или `std::wprintf` используя спецификатор `%ls`.
- Имеет внутренние проблемы, не позволяющие корректно работать операторам `std::cout` и `std::wcout` для отображения символов, отличающихся от ASCII.
- Для компилятора MinGW64 требуется дополнительно установить буфер вывода на консоль для корреткной работы функций `pritnf` и `std::printf`.

##### Windows Clang

```
clang version is 11.0.0
```
- Позволяет отобразить UTF-8 строку, хранящуюся в типе `std::string` при помощи `printf` или `std::printf`, используя спецификатор `%s`.
- Позволяет отобразить UTF-16 строку, хранящуюся в типе `std::wstring` при помощи `wprintf`, используя спецификатор `%s`.
- Позволяет отобразить UTF-16 строку, хранящуюся в типе `std::wstring` при помощи `std::wprintf`, используя спецификаторы `%s` или `%ls`
- Позволяет отобразить UTF-8 строку при помощи `std::cout`, и UTF-16 строку при помощи `std::wcout`.

##### Windows VS2019

```
msbuild version is 16.6.0.22303
```
- Позволяет отобразить UTF-8 строку, хранящуюся в типе `std::string` при помощи `printf` или `std::printf`, используя спецификатор `%s`.
- Позволяет отобразить UTF-8 строку при помощи `std::cout`.
- Не получилось заставить работать `wprintf`, `std::wprintf` или `std::wcout` с широкими строками - по непонятной причине их содержимое считается компилятором как UTF-8.


##### Linux G++ и C++

```
c++ and g++ version is (Debian 8.3.0-6) 8.3.0
```

- Позволяет отобразить UTF-8 строку, хранящуюся в типе `std::string` при помощи `printf`, `std::printf`, `wprintf` или `std::wprintf` используя спецификатор `%s`.
- Позволяет отобразить UTF-16 строку, хранящуюся в типе `std::wstring` при помощи `wprintf` или `std::wprintf`, используя спецификатор `%ls`.
- Позволяет отобразить UTF-8 строку с помощью `std::cout`.
- Позволяет отобразить UTF-16 строку с помощью `std::wcout` если установить локаль: `setlocale(LC_ALL, "en_US.UTF-8");`.


Пример работы с unicode представлен в [моём репозитории на github](https://github.com/gek0n/UnicodeOutputTest).

### Ссылки

#### Информация по теме
1. [Blog post about encodings and charsets](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)
2. [System locales in Linux](https://www.tecmint.com/set-system-locales-in-linux/)
3. [Unicode symbol table](https://unicode-table.com/ru/)
4. [Official unicode website](https://home.unicode.org/)
5. [Fonts in Linux](https://ru.wikibooks.org/wiki/%D0%A8%D1%80%D0%B8%D1%84%D1%82%D1%8B_%D0%B2_Linux)
6. [Unicode - it is very fascinatingly](https://habr.com/ru/post/319602/)
7. [Unicode conversion in Windows apps](https://docs.microsoft.com/ru-ru/archive/msdn-magazine/2016/september/c-unicode-encoding-conversions-with-stl-strings-and-win32-apis)
8. [Reading UTF-8 with C streams](https://www.codeproject.com/Articles/38242/Reading-UTF-8-with-C-streams)
9. [Available locale names on Windows](https://stackoverflow.com/questions/4406895/what-stdlocale-names-are-available-on-common-windows-compilers/4497266#4497266)

#### Использованные источники
[0]: https://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4 "Unicode encoding (Wikipedia)"
[1]: https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/unattend/microsoft-windows-international-core-winpe-systemlocale "Windows System locale (MSDN)"
[2]: https://man7.org/linux/man-pages/man7/locale.7.html "Linux system locale"
[3]: https://en.wikipedia.org/wiki/Windows_code_page#:~:text=ANSI%20code%20page,-Windows%2D125x%20series&text=ANSI%20code%20pages%20(officially%20called,user%20interface%20on%20Windows%20systems. "Windows code page (Wikipedia)"
[4]: https://docs.microsoft.com/en-us/windows/win32/intl/code-pages "Code pages (MSDN)"
[5]: https://en.wikipedia.org/wiki/Unicode_in_Microsoft_Windows "Unicode in Windows (Wikipedia)"
[6]: https://docs.microsoft.com/en-us/windows/win32/intl/unicode "Unicode in Windows (MSDN)"
[7]: https://stackoverflow.com/questions/14109024/how-to-make-unicode-charset-in-cmd-exe-by-default "Change default cmd.exe encoding (StackOverflow)"
[8]: https://docs.microsoft.com/ru-ru/windows/console/setconsoleoutputcp "Function SetConsoleOutputCP (MSDN)"
[9]: https://ru.wikipedia.org/wiki/TrueType#:~:text=TrueType%20(%C2%AB%D1%82%D1%80%D1%83%D1%82%D0%B0%D0%B9%D0%BF%C2%BB)%20%E2%80%94,%D0%B8%D0%BC%D0%B5%D1%8E%D1%82%20%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B8%D0%BC%D0%B5%D0%BD%D0%B8%20%C2%ABttf%C2%BB. "TrueType fonts"
[10]: https://en.wikipedia.org/wiki/NTFS "NTFS filesystem (Wikipedia)"
[11]: https://www.ibm.com/support/knowledgecenter/en/SSEPGG_10.5.0/com.ibm.db2.luw.admin.nls.doc/doc/c0051307.html "Linux default encoding"
[12]: https://stackoverflow.com/a/45809387/3212675 "Linux locale (StackOverflow)"
[13]: https://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html "Locale categories (GNU)"
[14]: https://www.gnu.org/software/libc/manual/html_node/Standard-Locales.html "Standard locales (GNU)"
[15]: https://www.tecmint.com/set-system-locales-in-linux/ "Set linux system locale"
[16]: https://unix.stackexchange.com/questions/38055/utf-8-filenames "Linux filename encoding (StackOverflow)"
[17]: https://en.cppreference.com/w/cpp/string/byte "Null-terminated byte strings"
[18]: https://en.cppreference.com/w/cpp/string/multibyte "Null-terminated multibyte strings"
[19]: https://en.cppreference.com/w/cpp/string/wide "Null-terminated wide strings"
[20]: https://en.cppreference.com/w/cpp/string "Strings library in C++"
[21]: https://en.cppreference.com/w/cpp/language/types "Fundamental types C++"
[22]: https://en.cppreference.com/w/cpp/language/string_literal "String literal C++"
