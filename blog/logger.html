<!doctype html>
<html lang="en">
  <head>
    <title>Blog| Создание класса Logger</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/css/w3.css">
    <link rel="stylesheet" href="/media/css/blog/article.css">
    <link href="http://fonts.googleapis.com/css?family=Anton"
            rel="stylesheet" type="text/css">

    <!-- Turn on code highlighting -->
    <link rel="stylesheet" href="/media/css/highlight/hybrid.css">
    <script src="/media/js/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <meta name="author" content="Загурский Михаил" />
    <meta name="description" content="Article about invention Logger class" />
    <meta name="generator" content="Hyde 0.8.9" />
    <meta name="keywords" content="logger" />
  </head>
  <body onload="addW3ClassesToImages();">
    <nav id="main" class="w3-bar w3-black w3-top">
    <a href="/index.html" class="w3-bar-item w3-button ">Главная</a>
    <a href="/blog/listing.html" class="w3-bar-item w3-button  w3-hide-small ">Блог</a>
    <a href="/about.html" class="w3-bar-item w3-button  w3-hide-small ">Резюме</a>
    <a href="#" class="w3-bar-item w3-button w3-hide-large w3-hide-medium w3-right" title="Страницы" onClick="toogleNavMenu()">Страницы</a>
  <div id="smallMenu" class="w3-bar w3-black w3-bar-block w3-hide">
        <a href="/blog/listing.html" class="w3-bar-item w3-button">Блог</a>
        <a href="/about.html" class="w3-bar-item w3-button">Резюме</a>
      </div>
</nav>
    <header class="w3-container w3-center w3-padding-64 w3-xxlarge w3-mobile">
      Создание класса Logger
    </header>
    
    <article class="w3-content w3-justify w3-container w3-col m11 l10" id="article">
      <p>Я считаю, что "изобретение велосипедов" в программировании имеет смысл только в учебных целях. В тех случаях, когда нам приходится писать коммерческую систему (вообще любую программу, которой должны пользоваться люди), желательно использовать как можно больше уже готовых и проверенных решений других команд. Конечно, как и в обычной жизни, перегибы в использовании чужого кода недопустимы:</p>
<ul>
<li>Доверяй, но проверяй (уверены, что чужой код работает, как заявлено)?</li>
<li>Лицензирование (код, который вы используете, выпущен под необходимой Вам лицензией)?</li>
<li>Полнота (иногда, готовое решение по своей функциональности не перекрывает поставленной задачи, а значит его использование в исходном виде является неприемлемым)</li>
</ul>
<p>Однако, иногда создаются проекты, в которых по тем или иным причинам невозможно использовать готовые библиотеки. В таких случаях необходимо написать минимальный необходимый вариант для решения задачи. Рассмотрим задачу логирования работы системы силами самописного класса <strong>Logger</strong>.</p>
<h3>Понятие логирования</h3>
<p>Некоторые разработчики путают понятие логирование и журналирование. По сути, это одинаковые действия, производимые программой для сохранения некоторой информации о своей работе для человека. При этом я разделяю эти понятие следующим образом:</p>
<blockquote>
<p><strong>Логирование</strong> - это информация, необходимая инженеру, ведущему поддержку своей разработки.</p>
<p><strong>Журналирование</strong> - это информация необходимая пользователю, работающему с программой.</p>
</blockquote>
<p>Разберём задачу логирования, помня о том, что чисто технически, задача журналирования решается теми же средствами.</p>
<h4>Зачем нужны логи</h4>
<p>В процессе изучения этой проблемы меня вполне удовлетворил список целей использования Logger из <a href="https://habrahabr.ru/post/98638/">этого источника</a>. Позволю себе кратко его пересказать своими словами:</p>
<ul>
<li>
<p><strong>Отладка</strong><br />
    Без использования отладчика<br />
    Не всегда есть отладчик под требуемую систему, не всегда есть время им пользоваться, не всегда отладчик позволяет легко "поймать" ошибку.</p>
</li>
<li>
<p><strong>Расследование</strong><br />
    В том числе и в сфере ИБ<br />
    Ошибки бывают плавающие, и тогда очень трудно понять, когда они возникают. Чтобы не пытаться безуспешно вызвать плавающую ошибку, пишут логи, которые при возникновении такой ошибки позволят быстро понять, что пошло не так.</p>
</li>
<li>
<p><strong>Профилирование</strong><br />
    В основном на динамически развивающихся системах</p>
</li>
</ul>
<p>Часто программа работает после деплоя немного иначе, нежели на процессе разработки. Это может быть связано с различной настройкой системы, использованием различного железа, получением разных входных данных. Тогда очень важно вовремя отслеживать возникающие "бутылочные горлышки" и вовремя их устранять.</p>
<p>Давайте определим, что такое идеальный логгер:</p>
<blockquote>
<p><strong>Идеальный логгер</strong> - логгер, который в плане функциональности полностью соответствует требованиям системы и не содержит неиспользуемых (ненужных) функций, он также должен быть написан максимально просто, производить запись информации максимально быстро и безопасно (логи не должны теряться), работать продолжительное время без изменений (ротация файлов, отказоустойчивость).</p>
</blockquote>
<p>Таким образом у каждой конкретной системы идеальный логгер будет обладать разным набором качеств. Чтобы не создавать огромное количество логгеров под каждую отдельную задачу, разработчики написали и стараются использовать универсальный логгер.</p>
<blockquote>
<p><strong>Универсальный логгер</strong> - логгер, написаный максимально просто, но одновременно с тем поддерживающий всю возможную функциональность таким образом, чтобы ненужные модули могли быть отключены и не использоваться.</p>
</blockquote>
<h3>Важные параметры логгеров</h3>
<h4>Уровни логирования</h4>
<p>Предназначены для разделения потоков сообщений по степени важности. Рассмотрим основные пять уровней логирования: DEBUG, INFO, WARNING, ERROR, FATAL. О ситуации, в которой надо использовать тот или иной вариант, очень хорошо написано <a href="https://habrahabr.ru/post/98638/">в статье</a>:</p>
<blockquote>
<p><strong>Debug</strong> сообщения отладки, профилирования.<br />
В production системе обычно сообщения этого уровня включаются при первоначальном запуске системы или для поиска узких мест (bottleneck-ов).<br />
<strong>Info</strong> обычные сообщения, информирующие о действиях системы.<br />
Реагировать на такие сообщения вообще не надо, но они могут помочь, например, при поиске багов, расследовании интересных ситуаций итд.<br />
<strong>Warn</strong> записывая такое сообщение, система пытается привлечь внимание обслуживающего персонала.<br />
Произошло что-то странное. Возможно, это новый тип ситуации, ещё не известный системе. Следует разобраться в том, что произошло, что это означает, и отнести ситуацию либо к инфо-сообщению, либо к ошибке. Соответственно, придётся доработать код обработки таких ситуаций.<br />
<strong>Error</strong> ошибка в работе системы, требующая вмешательства.<br />
Что-то не сохранилось, что-то отвалилось. Необходимо принимать меры довольно быстро! Ошибки этого уровня и выше требуют немедленной записи в лог, чтобы ускорить реакцию на них. Нужно понимать, что ошибка пользователя – это не ошибка системы. Если пользователь ввёл в поле -1, где это не предполагалось – не надо писать об этом в лог ошибок.<br />
<strong>Fatal</strong> это особый класс ошибок.<br />
Такие ошибки приводят к неработоспособности системы в целом, или неработоспособности одной из подсистем. Чаще всего случаются фатальные ошибки из-за неверной конфигурации или отказов оборудования. Требуют срочной, немедленной реакции. Возможно, следует предусмотреть уведомление о таких ошибках по SMS.</p>
</blockquote>
<p>Пример, хорошо иллюстрирующий, как надо выбирать уровни логирования, Вы также можете найти <a href="https://habrahabr.ru/post/98638/">здесь</a>. Конечно уровней может быть и больше, но это не существенно в рамках большинства задач.</p>
<h4>Формат логирования</h4>
<p>Формат в котором сообщения выводятся в соответствующий лог-файл (или любой другой вывод, предназначенный для ведения логов). Обычно библиотечные логгеры позволяют включать некоторую служебную информацию в строку сообщения:</p>
<ul>
<li>Время (от начала запуска программы, или глобальное);</li>
<li>Уровень сообщения (присвоенный сообщению уровень логирования);</li>
<li>Функция, в которой производится логирование (имя функции средствами рефлексии);</li>
<li>Текст сообщения (основная информация о событии);</li>
<li>Stack trace (позволяет понять место возникновения исключения;</li>
<li>и т. д.</li>
</ul>
<h4>Ротация лог-файлов</h4>
<p>При достижении некоторого условия, файл логирования должен автоматически подменяться новым. Стандартными ситуациями являются достижение определенного размера файла, наступление определенного события в системе или "старение" лог-файла.</p>
<h4>Направления вывода</h4>
<p>Хороший класс логирования позволяет писать разные уровни в разные хранилища. В роли хранилищ могут выступать файлы, базы данных, таблицы, память, экран, входной поток другого процесса, передавать по сети, ставить в очередь событий, оповещать по SMS и т. д.</p>
<h4>Потокобезопасность</h4>
<p>Использование класса <strong>Logger</strong> в многопоточных приложениях ни в коем случае не должно влиять на его работоспособность. Другими словами, не должно возникать взаимных блокировок, затирания данных, "гонок" и прочих ошибок работы в многопоточных приложениях.</p>
<h4>Асинхронность</h4>
<p>Иногда в лог необходимо поместить достаточно большие объёмы данных, в таком случае делать это в основном потоке программы нецелесообразно, потому что может приводить к зависаниям. Чтобы избежать подобных проблем, запись больших данных в лог иногда помещают в отдельный поток.</p>
<h4>Работа с исключениями</h4>
<p>При выводе информации об исключении в лог необходимо знать всю служебную информацию: название исключения, его параметры (имя, тип, где возникло и т. д.), Stack trace исключения. При этом необходимо, чтобы класс <strong>Logger</strong> сам умел преобразовывать в читаемый вид эту информацию без участия разработчика в процессе форматирования вывода.</p>
<h3>Архитектура логгера</h3>
<p>По условию задачи, мы не имеем возможности использовать библиотеки логирования любых сторонних производителей, а значит должны сами написать класс Logger. Так как общие принципы одинаковые для большинства объектно-ориентированных языков, то все примеры кода будут написаны с использованием псевдокода (похожего на код C#).</p>
<ol>
<li>Простейший Logger
<strong><em>Требования:</em></strong></li>
<li>умеет построчно писать в любой один файл в виде текста;</li>
<li>гарантирует сохранность лога при любом варианте завершения работы программы;</li>
<li>имеет пять вышеописанных уровней логирования.</li>
</ol>
<p><strong><em>Анализ требований:</em></strong>
Для хранения уровней логирования нас устроит обычное перечисление. В случае, если по каким-то причинам нельзя использовать перечисление, то подойдут обычные именованные константы.  Чаще всего для логирования используют статический класс, который фактически выполняет функции библиотеки: группирует внутри себя всю логику, не позволяя размазать логирование по другим классам.  Вот так выглядит скелет класса, который должен реализовать требуемую функциональность.</p>
<pre><code>public static class Logger
{
    public enum Level
    {
    DEBUG,
    INFO,
    WARNING,
    ERROR,
    FATAL
    }

    private static Level currentLevel = Level.DEBUG;
    private static string fileName = "logFIlename.log";

    public static Log(Level level, string message)
    {
    if(currentLevel &amp;gt;= level)
    {
    Log(level, string message, null);
    }
    }

    public static Log(Level level, string message, Exception exception)
    {
    if(currentLevel &amp;gt;= level)
    {
    if(/*файл существует*/)
    {
    /*Открываем файл для добавления*/
    /*Пишем в файл строку*/
    /*Закрываем файл*/
    }
    }
    }
}
</code></pre>
<p>Реализация записи в файл построчно сильно зависит от языка программирования, на котором пишется класс,а потому не приведена здесь совсем. Вместо этого я добавил комментарии, которые приблизительно описывают требуемые действия.</p>
<ol>
<li>Более удобный Logger
<strong><em>Дополнительные требования:</em></strong></li>
<li>Должен иметь методы, соответствующие уровням вывода сообщений (для удобства);</li>
<li>Должен получать настройки из файла (хотя бы уровень логирования и имя лог-файла);</li>
<li>Должен иметь возможность ротации файлов.</li>
</ol>
<p><strong><em>Анализ требований:</em></strong>
Создадим группу перегруженных методов, для более удобного использования в логируемом коде, тогда отпадёт необходимость указывать уровень логирования. Настройки из файла получаются один раз при запуске программы, поэтому инициализация помещена в статический конструктор класса (типа). Он вызывается один раз при создании в памяти этого типа (а не экземпляров типа). Так как класс статический, то и все его члены тоже должны быть статическими. Для реализации ротации файлов поместим в файл настроек два дополнительных параметра: лимит по времени и лимит по размеру.  Если представить, что настройки хранятся в файле типа json, то файл настроек может выглядеть следующим образом:</p>
<pre><code>{
    "currentLevel": 0,
    "logFileName": "simple.log",
    "rotationSizeLimit": 100,
    "rotationTimeLimit": "10:00:00"
}
</code></pre>
<p>&nbsp;</p>
<pre><code>public static class Logger
{
    public enum Level
    {
    DEBUG,
    INFO,
    WARNING,
    ERROR,
    FATAL
    }

    private static  Level _currentLevel;
    private static string _fileName;
    private static unsigned int _rotationSizeLimit;
    private static DateTime _rotationTimeLimit;

    static Logger()
    {
    if(/*Файл настроек не существует*/)
    {
    throw new Exception();  // Выбрасываем исключение, специфичное для вашего языка
    }
    /*Открываем файл на чтение*/
    string settings = /*Читаем все данные из файла в переменную*/;
    /*Закрываем файл*/
    ParseSettings(settings);
    }

    private static void ParseSettings(string settings)
    {
    /*Как-то парсим настройки*/
    _currentLevel = /*какое-то значение уровня*/;
    _fileName = /*какое-то имя файла*/;
    _rotationTimeLimit = /*Какое-то значение*/;
    _rotationSizeLimit = /*Какое-то значение*/;
    }

    public static Log(Level level, string message)
    {
    if(_currentLevel &amp;gt;= level)
    {
    Log(level, string message, null);
    }
    }

    public static Log(Level level, string message, Exception exception)
    {
    if(_currentLevel &amp;gt;= level)
    {
    if(/*файл _fileName существует*/)
    {
    if(IsNeedRotation(/*Указатель на файл*/))
    {
        /*Переименовываем старый файл (если необходимо, либо новый файл должен быть с новым именем)*/
        /*Создаём новый файл*/
    }
    else
    {
        /*Открываем файл для добавления*/
    }
    }
    else
    {
    /*Создаём новый файл*/
    }
    /*Пишем в файл строку*/
    /*Закрываем файл*/
    }
    }

    public static IsNeedRotation(/*Указатель на файл*/)
    {
    return (_rotationSizeLimit != -1 &amp;amp;&amp;amp; /*размер файла*/ &amp;gt;= _rotationSizeLimit) 
    || (_rotationTimeLimit != null &amp;amp;&amp;amp; /*Дата создания файла*/ &amp;gt;= _rotationTimeLimit);
    }

    public static Debug(string message)
    {
    if(_currentLevel &amp;gt;= Level.DEBUG)
    {
    Log(Level.DEBUG, message);
    }
    }

    public static Debug(string message, Exception exception)
    {
    if(_currentLevel &amp;gt;= Level.DEBUG)
    {
    Log(Level.DEBUG, message, exception);
    }
    }

    public static Info(string message)
    {
    if(_currentLevel &amp;gt;= Level.INFO)
    {
    Log(Level.INFO, message);
    }
    }

    public static Info(string message, Exception exception)
    {
    if(_currentLevel &amp;gt;= Level.INFO)
    {
    Log(Level.INFO, message, exception);
    }
    }

    public static Warn(string message)
    {
    if(_currentLevel &amp;gt;= Level.WARNING)
    {
    Log(Level.WARNING, message);
    }
    }

    public static Warn(string message, Exception exception)
    {
    if(_currentLevel &amp;gt;= Level.WARNING)
    {
    Log(Level.WARNING, message, exception);
    }
    }

    public static Error(string message)
    {
    if(_currentLevel &amp;gt;= Level.ERROR)
    {
    Log(Level.ERROR, message);
    }
    }

    public static Error(string message, Exception exception)
    {
    if(_currentLevel &amp;gt;= Level.ERROR)
    {
    Log(Level.ERROR, message, exception);
    }
    }

    public static Fatal(string message)
    {
    if(_currentLevel &amp;gt;= Level.FATAL)
    {
    Log(Level.FATAL, message);
    }
    }

    public static Fatal(string message, Exception exception)
    {
    if(_currentLevel &amp;gt;= Level.FATAL)
    {
    Log(Level.FATAL, message, exception);
    }
    }
}
</code></pre>
<p>Дальнейшие улучшения требуют композиции всех методов работы с файлом в отдельный класс. Также следует заметить, что дальнейшее улучшение <strong>Logger</strong> (при помощи добавления новых функций) является сложной операцией и, возможно, уже стоит всё-таки найти способ использовать стороннюю библиотеку.</p>
<ol>
<li>
<p>Асинхронный Logger
В большинстве языков программирования присутствуют асинхронные функции записи в файл. Используйте их в функции <strong>Log</strong>, чтобы добиться асинхронной записи в файл. Также не забудьте, что при завершении работы программы следует позаботиться о том, чтобы все асинхронные операции завершились, иначе данные могут потеряться.</p>
</li>
<li>
<p>Потокобезопасный Logger
Чтобы использовать такой логгер в многопоточном приложении, необходимо добавить в реализацию функции работы с файлом мьютексы (в разных языках программирования могут называться по разному). Ваша задача позаботиться о том, чтобы файл блокировался на запись на минимально возможное время и при этом не возникало deadlock`ов. Это улучшение уже требует определенных навыков программирования и существенно снижает отказоустойчивость Logger при хоть сколько-нибудь неверной реализации.</p>
</li>
<li>
<p>Logger поддерживающий разные направления вывода
Не всегда удобно использовать именно запись в файл. Вместо этого можно передавать данные куда угодно, хоть по сети. Однако, стоит помнить, что если Вам необходимо писать в несколько мест, да ещё и не дай Бог в многопоточном приложении, то рекомендую любыми силами найти возможность использовать готовые библиотеки. Как минимум брать из них примеры кода. Если же необходимо использовать несколько логгеров, то можно воспользоваться шаблоном "Цепочка обязанностей".</p>
</li>
</ol>
<h3>Использование логгера</h3>
<p>Пример вызова методов класса будет выглядеть примерно вот так: <code>cppLogger.Debug("Something happens")</code>
Метод <strong>Debug()</strong> следует использовать в местах, где необходимо получить данные, не описывающие значимые события системы, но необходимые для настройки её корректного функционирования.
<strong><em>Например:</em></strong></p>
<pre><code>public int calculateDaysBeforeSunday()
{
    Logger.Debug("Вход в тело функции");
    var daysBeforeMonday = getDaysBeforeMonday();
    Logger.Debug(string.Format("Days before monday: %d", daysBeforeMonday);
    var result = daysBeforeMonday - 1;
    Logger.Debug("Выход из функции");
    return result;
}
</code></pre>
<p>В данном участке кода метод <strong>Debug()</strong> используется для вывода в лог служебной информации, позволяющей отследить исполнение функции <strong>calculateDaysBeforeSunday()</strong>. Эти данные не будут полезны после того как приложение будет готово, но могут оказать очень полезными на этапе разработки.</p>
<p>Метод <strong>Info()</strong> следует использовать в местах, где происходят важные для системы события, однако они являются штатными и не требуют вмешательства извне.
<strong><em>Например:</em></strong></p>
<pre><code>public void Registration(string email, string password)
{
    if(IsCorrectEmail(email) &amp;&amp; IsSecurePassword(password)
    {
    writeNewUserToDb(email, password);
    Logger.Info(string.Format("Пользователь с адресом почты %s был успешно зарегистрирован", email);
    }
}
</code></pre>
<p>Из приведенного участка кода видно, что при успешной регистрации пользователя информация об этом попадает в лог-файл, а система продолжает работу в штатном режиме. Фактически этот метод может использоваться для журналирования (особенно если запись ведётся в отдельный файл).</p>
<p>Метод <strong>Warn()</strong> следует использовать в местах, где происходит неожиданная ситуация, не влияющая на работоспособность системы, однако не предусмотренная разработчиком.
<strong><em>Например:</em></strong></p>
<pre><code>public File OpenFileVer2(string filename)
{
    if(File.IsExist(filename)
    {
    if(checkFileVersion(filename) == "ver. 1")
    {
        Logger.Debug("Попытка открыть файл версии 1 как файл версии 2. Некоторые данные могут быть отображены некорректно");
    }
    return Open(filename, "rb", "ver. 2");
    }
    return null;
}
</code></pre>
<p>Как видно из примера, в случае если пользователь принудительно заставил программу открыть файл первой версии функция отработает нормально, однако предупредит о том, что была использована не по назначению. В идеале, таких ситуаций в программе должно быть как можно меньше, и как правильно заметил автор статьи <a href="https://habrahabr.ru/post/98638/">1</a>, в последующем такие ситуации должны быть переквалифицированы в Информационные или Ошибочные.</p>
<p>Метод <strong>Error</strong> является одним из самых часто применяемых. В подавляющем большинстве случаев он используется для того, чтобы логировать исключения. Его появление в логе говорит о том, что какая-то часть системы отработала неверно, однако это не обязательно ведёт за собой сбой работы всего приложения.</p>
<p><strong><em>Например:</em></strong></p>
<pre><code>public float calculateDummyBodyMassIndex(float weight, float height)
{
    float dummyIndex = 0.0;
    try
    {
    dummyIndex = weight / height;
    }
    catch(ZeroDivisionException e)
    {
    Logger.Error("Не указан рост. Индекс не будет рассчитан!", e);
    }
    return dummyIndex;
}
</code></pre>
<p>В случае, если функция отработает неверно из-за плохих входных данных, то программа не "сломается", однако в логе будет присутствовать сообщение, сигнализирующее о том, что произошёл сбой в результате которого был получен неожиданный результат. На такие события следует быстро реагировать и тщательно устранять причины их возникновения.</p>
<p>Метод <strong>Fatal()</strong> пожалуй самый редко используемый метод. Появление такого события в логе говорит о том, что программа не смогла выполнится успешно, поэтому будет завершена. Фактически это как BSOD только не для операционной системы, а для приложения. Именно такие события и логирует этот метод.
<strong><em>Например:</em></strong></p>
<pre><code>public void LoadDecryptPayloadAlgorithm()
{
    if(!IsNetworkAvailable())
    {
    Logger.Fatal("Network is anavailable! Can't load decryption algorithm. Program can't execute");
    exit(NOT_AVAILABLE_PAYLOAD);
    }
    // ...
}
</code></pre>
<p>Предположим, что программа упакована при помощи некоторого облачного упаковщика. Следовательно для её работы необходимо получить по сети код распаковщика, распаковать себя и начать выполнение. Если сеть будет недоступна, то и программа не сможет корректно функционировать. Поэтому будет завершена немедленно.</p>
<h3>Заключение</h3>
<p>Использовать самописный класс Logger не рекомендуется, однако в случае если это необходимо, следует придерживаться следующих правил проектирования класса:</p>
<ul>
<li>Должен быть проще палки. Ещё проще!</li>
<li>Должен реализовывать только минимально необходимый функционал;</li>
<li>Как минимум должен иметь пять уровней логирования;</li>
<li>Должен писать только в один поток (файловый, сетевой, бинарный, и т. д.);</li>
<li>Желательно делать статическим, чтобы ни один объект в системе не отвечал за его жизненный цикл</li>
</ul>
<hr />
<h4>Использованные источники:</h4>
<ol>
<li><a href="https://habrahabr.ru/post/98638/">https://habrahabr.ru/post/98638/</a></li>
<li><a href="https://stackoverflow.com/questions/5057567/how-to-do-logging-in-c">https://stackoverflow.com/questions/5057567/how-to-do-logging-in-c</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/221490/which-design-pattern-is-more-suitable-for-logging">https://softwareengineering.stackexchange.com/questions/221490/which-design-pattern-is-more-suitable-for-logging</a></li>
<li><a href="https://www.thekua.com/atwork/2008/11/application-logging-principles/">https://www.thekua.com/atwork/2008/11/application-logging-principles/</a></li>
<li><a href="https://docs.python.org/3/howto/logging.html">https://docs.python.org/3/howto/logging.html</a></li>
<li><a href="https://habrahabr.ru/post/313686/">https://habrahabr.ru/post/313686/</a></li>
</ol>    </article>
    <footer class="w3-row-padding w3-center w3-padding-16">
      <div class="w3-row">
        <div class="w3-third">
          <h3>About</h3>
        </div>
        <div class="w3-third">
          <h3>Recent posts</h3>
          <ul id="articles" class="w3-ul w3-hoverable" style="max-width:400px;margin:auto;">
                    <li>
            <div class="w3-cell-row w3-container">
              <div class="w3-cell">
                            </div>
              <div style="w3-cell w3-cell-middle w3-container">
                <a href="/blog/named_pipe.html">Создание именованного пайпа в привилегированном процессе</a>
              </div>
            </div>
          </li>
                    <li>
            <div class="w3-cell-row w3-container">
              <div class="w3-cell">
                            </div>
              <div style="w3-cell w3-cell-middle w3-container">
                <a href="/blog/file_ctx.html">Передача файлового контекста</a>
              </div>
            </div>
          </li>
                    <li>
            <div class="w3-cell-row w3-container">
              <div class="w3-cell">
                              <img class="w3-image w3-padding-small" src="/media/img/icons/ctf.png"/>
                            </div>
              <div style="w3-cell w3-cell-middle w3-container">
                <a href="/blog/ctf/ructf_2014_quals_hardware_100.html">RUCTF 2014 QUALS - HARDWARE 100</a>
              </div>
            </div>
          </li>
                    </ul>
        </div>
        <div class="w3-third">
          <h3>Tags</h3>
                                                                    <span class="w3-tag w3-margin-bottom w3-gray">writeup</span>
                                                                    <span class="w3-tag w3-margin-bottom w3-gray">ctf</span>
                                                                                                  <span class="w3-tag w3-margin-bottom w3-dark-gray">wip</span>
                  </div>
      </div>
      <div class="w3-wide w3-opacity w3-tiny w3-text-dark-grey">
        Generated with <a href="https://github.com/hyde/hyde">the Hyde</a>
        <br>
        Powered by <a href="https://www.w3schools.com/w3css/default.asp" target="_blank">w3.css</a>
      </div>
    </footer>
    <script>
    function toogleNavMenu() {
      var smallMenu = document.getElementById("smallMenu");
      if (smallMenu.className.indexOf("w3-show") == -1) {
        smallMenu.className += " w3-show";
      } else {
        smallMenu.className = smallMenu.className.replace(" w3-show", "");
      }
    }

    function addW3ClassesToImages() {
      var imgs = document.getElementById("article").getElementsByTagName("img");
      for (i = 0; i < imgs.length; i++) {
        console.log(imgs[i].src);
        imgs[i].className += " w3-card";
        imgs[i].className += " w3-image";
      }
    }
    </script>
  </body>
</html>